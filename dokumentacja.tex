\documentclass{article}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\title{Dokumentacja projektowa}
\date{2018-03-18}
\author{Jędrzej Kozal}

\begin{document}

\begin{titlepage}
	\centering
	\includegraphics[width=0.25\textwidth]{logo_pol_wroclaw.png}\par\vspace{1cm}
	{\scshape\LARGE Politechnika Wrocławska \par}
	\vspace{1cm}
	{\scshape\Large Zastosowanie informatyki w gospodarce\par}
	\vspace{1.5cm}
	{\huge\bfseries Aplikacja do rezerwacji miejsc w restauracjach \par}
	\vspace{2cm}
	{\Large\itshape Hubert Duś\par}
	{\Large\itshape Jędrzej Kozal\par}
	{\Large\itshape Eliza Mocek\par}
	{\Large\itshape Piotr Montewka\par}

	\vfill
	prowadzący\par
	Dr inż.~Marek \textsc{Woda}

	\vfill

% Bottom of the page
	{\large \today\par}
\end{titlepage}


\section{Wstęp}

\subsection{Cel projektu}
Celem projektu realizowanego w ramach kursu, jest stworzenie aplikacji biznesowej, umożliwiającej rezerwacje miejsc w wybranych restauracjach. Zakłada się, że tworzona aplikacja będzie umożliwiała rezerwację miejsc w restauracji w porozumieniu z właścicielem i obsługą. Analogicznym pomysłem może być rezerwacja miejsc w kinie, która najczęściej odbywa się drogą elektroniczną. Tworzona aplikacja ma ułatwić pracę restauratorom i pozwolić na lepsze zarządzanie dostępnym miejscem oraz pośrednio zaopatrzeniem i personelem.

Ponadto istotnym celem projektu, jest zapoznanie się z realiami pracy nad dużym projektem informatycznym oraz analiza i próba rozwiązania podstawowych problemów jakie są związane z tym zagadnieniem. Projekt może być wymagający na poziomie technicznym, jak i komunikacyjnym. Przed przystąpieniem do aktywności zawodowej nie jest łatwo zdobyć doświadczenie w zakresie pracy w większym zespole inżynierskim.
\subsection{Zakres projektu}
Podstawowy zakres funkcjonalności można rozważać z perspektywy klienta, chcącego zamówić miejsce w restauracji, oraz właściciela i obsługi rezerwacji. Klient dzięki aplikacji powinien mieć zdolność zarezerwowania miejsca w wybranej przez siebie restauracji. Restauratorzy powinni mieć zdolność dodawania własnych rezerwacji oraz potwierdzania rezerwacji danych użytkowników. Aplikacja ma ułatwić i zautomatyzować komunikację między klientami a restauracjami. Warto zaznaczyć, że aplikacja nie udostępnia narzędzi umożliwiających zarządzanie restauracjami. W celu osiągnięcia przedstawionego celu należy stworzyć stronę internetową umożliwiającą dostęp do wybranych funkcjonalności, połączoną z aplikacją webową z dostępem do bazy danych.



\section{Analiza wymagań}

\subsection{Analiza rynkowa}
Potencjalna grupa docelowa odbiorców?
\subsubsection{Dostępne rozwiązania}

Na rynku jest dostępnych kilka aplikacji oferujących zbliżony zakres funkcjonalności do przedstawionego. Poniżej przedstawiono pobieżną analizę dostępnych rozwiązań.

\paragraph{gastrobooking.pl}
Popularny w polsce serwis do rezerwacji miejsc w restauracjach. W Polsce umożliwia rezerwację stolików jedynie w Krakowie. 

\paragraph{quandoo.com}


\paragraph{zomato.com}

\paragraph{opentable.com}
Jest to aplikacja posiadająca najwięszką bazę restauracji (40 000) w 14 krajach. Na Polskim rynku dostępne są jedynie dwie restauracje. 

\subsubsection{Analiza wymagań biznesowych}

Wymienione w poprzednim paragrafie serwisy nie występują w Polsce, lub są słabo rozpowszechnione. W porównaniu do konkurencji podstawową zaletą aplikacji ma być jej niska cena, oraz prostota. Zwiększa to zakres firm, który mogłyby sobie pozwolić na wdrożenie naszej aplikacji, co na dłuższą metę może stanowić o większej popularności.

Główną grupą docelową naszego produktu są restauratorzy oraz obsługa restauracji z dużą liczbą rezerwacji. Dzięki przygotowanej aplikacji mogą skorzystać z najnowszych rozwiązań technicznych, aby lepiej zarządzać swoją dostępnymi miejscami, oraz personelem. Zintegrowanie opracowanego systemu z innymi systemami umożliwiającymi zarządzanie personelem, kosztami czy zamówieniami znacząco ułatwiałoby zarządzanie i podejmowanie właściwych decyzji na poziomie managerskim. 


\subsection{Wymagania funkcjonalne}

\begin{figure}
\centering
	\includegraphics[width=0.90\textwidth]{use_case.jpg}
	\caption{Schemat przypadków użycia systemu.}
\end{figure}

\subsubsection{Podstawowe przypadki użycia}

Użytkowników aplikacji można podzielić na 3 grupy. Każda z grup posiada własne przypadki użycia.
\begin{enumerate}
\item klient restauracji, niezalogowany użytkownik
\begin{enumerate}
	\item przeglądanie profilu restauracji \\
	Niezalogowany użytkownik może wyświetlać profil restauracji i ma dostęp do wszystkich informacji zawartych w profilu.
	\item rejestracja \\
	Większość przypadków użycia jest dostępnych po rejestracji i zalogowaniu.
\end{enumerate}
	\item klient restauracji, zalogowany użytkownik
\begin{enumerate}
	\item złożenie rezerwacji \\
	Klient ma możliwość wyboru daty i godziny rezerwacji. Na podstawie informacji o dostępności stolików system daje informację zwrotną, czy rezerwacja w wybranych godzinach jest możliwa. Klient dokonuje rezerwacji, która następnie musi być zatwierdzona przez restaurację.
	\item dodawanie opinii o restauracji \\
	Użytkownik ma możliwość dodatnia opinii, która będzie widoczna dla wszystkich użytkowników w profilu wybranej restauracji.
	\item przeglądanie dodanych opinii \\
	Klient ma dostęp do wcześniej dodanych opinii w swoim profilu.
	\item przeglądanie ulubionych restauracji \\
	Na podstawie historii rezerwacji prezentowana jest lista ulubionych restauracji, która jest prezentowana użytkownikowi po zalogowaniu.
	\item przeglądanie historii rezerwacji \\
	Użytkownik ma dostęp do historii własnych rezerwacji.
	\item wysyłanie wiadomości do restauracji \\
	Klient może się komunikować bezpośrednio z restauracją przez stronę internetową.
	\item polecane restauracje \\
	Na postawie historii rezerwacji, oraz preferencji użytkowników o podobnych cechach prezentowana jest lista restauracji, które mogą się spodobać użytkownikowi. Do wyznaczania listy stosuje się algorytm kNN.
\end{enumerate}
\item restaurator
\begin{enumerate}
	\item zmiana informacji odnośnie restauracji \\
	Restaurator posiada możliwość zmiany danych prezentowanych na profilu restauracji. Zaliczają się do nich informacje o nazwie, adresie i zdjęcia. Restaurator nie ma wpływu na opinie widoczne na profilu jego restauracji.
	\item potwierdzenie rezerwacji \\
	Po złożeniu rezerwacji przez użytkownika, musi zostać ona zatwierdzona przez restaurację. W trakcie ewaluacji danej rezerwacji pomocne może być przeglądanie profilu klienta.
	\item wysłanie wiadomości do klienta
	Opcja bezpośredniej komunikacji przez stronę internetową.
	\item przeglądanie profilu klienta
	Restaurator ma dostęp do profilu klienta.
\end{enumerate}
\item administrator
\begin{enumerate}
	\item dodanie restauracji
	Dodawanie restauracji powinno być kontrolowane, aby uniknąć udostępniania nieprawdziwych bądź niewłaściwych informacji użytkownikom. W celu ułatwienia procesu weryfikacji danych, tylko administrator ma możliwość dodania restauracji do systemu.
	\item pełny dostęp do bazy danych
	Administrator może dodawać, usuwać, modyfikować i odczytywać wszystkie tabele w bazie. 
\end{enumerate}
\end{enumerate}


\subsection{Wymagania niefunkcjonalne}

\subsubsection{Wykorzystane technologie i narzędzia}

Projekt został zrealizowany z wykorzystaniem języka C\# oraz frameworka ASP.NET MVC. Do realizacji frontendu zostały wykorzystane HTML5, CSS 3.0 oraz JavaScript. Jako system zarządzania bazą danych wykorzystano Microsoft SQL Server.

\begin{figure}[h]
\centering
		\begin{minipage}{2cm}
			\includegraphics[width=2cm]{c_hasztag.png}
		\end{minipage}
		\begin{minipage}{2cm}
			\includegraphics[width=2cm]{asp_net-MVC.png}
		\end{minipage}
		\begin{minipage}{2cm}
			\includegraphics[width=2cm]{html.png}
		\end{minipage}
		\begin{minipage}{2cm}
			\includegraphics[width=2cm]{sql.png}
		\end{minipage}
	\caption{Wykorzystane technologie.}
	\label{fig:technologie}
\end{figure}

\begin{itemize}

\item Język programowania C\# \\\\
C\# jest obiektowym językiem programowania, który oficjalnie przedstawiony został w 2000 roku. Powstał na zlecenie firmy Microsoft, aby ułatwić tworzenie oprogramowania dla systemu operacyjnego Windows. W początkowej fazie swojego istnienia język był wspierany wyłącznie przez Microsoft, dlatego też rozpatrując język nieodzownym elementem było platforma programistyczna .NET. Jednak jego dobrze przemyślana struktura sprawiła, że język stał się popularny i powstało dla niego kilka open source standardów (m.in. Mono). Od 2016 roku Microsoft zmieniło swoją politykę i stworzyło .Net Core, które stało się praktycznie w pełni open source projektem. 

\item Platforma .NET \\\\
Do roku 2016 .NET rozwijały się dwa podejścia co do środowisk uruchomieniowych, czyli oficjalną
wersję opublikowaną przez Microsoft, jak i tworzoną przez pasjonatów wersja open source. Jednak wraz z
publikacją .NET Core 1.0 rozwój platformy został połączony w jedno. Wprowadzono ujednolicony standard
platformy (.NET Standard Library). Dzięki temu tworzone od teraz biblioteki są możliwe w użyciu również dla .NET Core, Xamarin i .NET Framework. Platforma .NET wspiera nie tylko język C\# ale również takie języki jak m.in. F\#, Visual Basic, C++. .NET Framework udostępnia specyficzne dla systemu operacyjnego Windows API takie jak Windows Forms i WPF (tworzenie aplikacji okienkowych). .NET Core zakłada całkiem odmienne podejście do przeznaczenia od wcześniejszego standardu. Głównym
założeniem jest wieloplatformowość. Przykładem API są: ASP.NET Core (aplikacje webowe) oraz Universal Windows Platform (docelowo reużywalne oprogramowanie działające zarówno na komputerach, urządzeniach mobilnych, jak i dla aplikacji wspierający Internetu rzeczy itd.). Mono for Xamarin w tej chwili wersja .NET dla aplikacji działających pod iOS oraz Android. Historycznie opensource’owa wersja standardu .NET Framework.
\item ASP.NET Core 2.0 \\\\
ASP.NET to API umożliwiające tworzenie aplikacji webowych\cite{asp}, czyli takie, które do swojego działania potrzebują jedynie przeglądarki internetowej. Nie wymagają od użytkownika instalowania zewnętrznego oprogramowania. Dzięki temu stworzone aplikację działają na wielu platformach jednocześnie. Dodatkowo wszelkie zmiany wprowadzane są wyłącznie po stronie serwera (nie angażują użytkownika). Do głównych elementów API zaliczamy: Web Forms, MVC (MVC + Web Page + Web API) oraz SignalR. Wprowadzenie standardu .NET Core uporządkowało kwestie związane z różnym podejściem tworzenia aplikacji webowych. Web Forms oraz Web Page praktycznie przestały istnieć.

\item Bootstrap \\\\
Biblioteka zapewniająca głównie style CSS, ale również określa ich zachowanie (wykorzystuje JavaScript). Główną zaletą Bootstrap jest to, że wspomaga tworzenie responsywnych aplikacji webowych, to znaczy, że powinny dobrze wyglądać nie tylko na monitorze, ale również na tablecie, czy telefonie komórkowym. Pomaga w kontrolowaniu zachowania gotowych komponentów HTML.

\item jQuery \\\\
JQuery jest biblioteką JavaScript ułatwiająca manipulacją drzewa DOM (Document Object Mode).
Wykorzystanie jQuery eliminuję problem interpretacji kodu JS przez różne przeglądarki. Jego niewątpliwą
zaletą jest wbudowanie AJAX. Sprawia, że opisane rozwiązanie jest czytelniejsze oraz wprowadza uproszczone
odwołanie się do elementów strony, oraz wykorzystania AJAX.

\item Entity Framework Core \\\\
Entity Framework Core to narzędzie pozwalające przetłumaczyć relacyjne bazy danych na obiekty. Narzędzia
te nazywamy ORM (Object Relational Mapping). Dzięki temu podejściu można tworzyć bazy danych bez użycia języka SQL. Ułatwia to zarządzanie danymi oraz przyspiesza pracę z nimi. Ponadto biblioteka ta zapewnia wsparcie nie tylko na poziomie tworzenia zapytań, ale również dzięki podejściu Code First możemy zaprojektować relacyjną bazę danych z poziomu języka obiektowego. Entity Framework pozwala także tworzyć automatycznie obiekty na podstawie już istniejącej bazy. Ostatnim wspieranym podejściem jest tworzenie bazy przy pomocy podejście Model first polegające na stworzeniu modelu w ADO.NET Entity Data Model Designer, a następnie Entity Framework tłumaczy go na obiekty oraz relacyjną bazę danych.

\end{itemize}

\subsubsection{Wykorzystane dobre praktyki}

W trakcie projektu przyjęto metodologię SOLID, oraz fragmenty metodologii Clean Code. Pozwala to na stworzenie łatwo rozszerzalnego kodu, który jest utrzymywalny i dobrze zorganizowany.

\section{Projekt systemu}

\subsection{Architektura systemu}

W niniejszym rozdziale przedstawiono ogólny przegląd architektury całej aplikacji, opartej na zalecanych sposobach pracy z wybranymi narzędziami.

\subsubsection{ASP.NET MVC}

Projekty wykonywane w frameworku ASP.NET MVC wymuszają pewną organizację projektu, która zwiększa uporządkowanie oraz wymusza korzystanie z dobrych praktyk. W projekcie można wyróżnić 4 zasadnicze części: Views, Controllers, Models i Router. Poniżej przedstawiono krótki opis poszczególnych części.

\paragraph{Model}
Modele są odpowiedzialne za przechowywanie informacji domenowej i stanu aplikacji. Najczęściej są implementowane jako Plain Old CLR Object (POCO) i służą do modelowania danych z bazy. Obiekty te są niezależne od frameworków, systemu zarządzania bazą danych czy mapowań ORM. Modele mogą być łączone w ViewModele, aby ułatwić grupowanie i przekazywanie informacji w aplikacji.

\paragraph{View}
Jest to frontendowa część projektu, która determinuje wygląd strony pokazywanej użytkownikowi. Technologie wykorzystywane w tym obszarze to HTML, CSS oraz JavaScript. Dodatkowo do widoku są przesyłane dane z innych komponentów w postaci modeli lub viewmodeli. ASP.NET MVC umożliwia dodawanie fragmentów kodu w C\# do ułatwienia wykorzystywania danych z modeli.

\paragraph{Controler}
Najczęściej jest to element implementujący wybraną część logiki biznesowej. Wykorzystuje dane z Modeli, aby wytworzyć i przekierować użytkownika do odpowiedniego Widoku. Każdy controler jest odpowiedzialny za obsługę HTTP Request. Taka organizacja wymusza podział projektu na mniejsze klasy z dobrze zdefiniowanym zakresem odpowiedzialności.

\paragraph{Router}
Jest to komponent, który odpowiada za mapowanie zapytań HTTP na poszczególne akcje w kontrolerach.
\\\\
Pierwsze trzy komponenty są dobrze znane ze wzorca projektowego na Model-View-Controler, natomiast ostatni jest często spotykanym dodatkiem w wielu frameworkach sieciowych, umożliwiający łatwe mapowanie. Konstrukcja frameworku MVC pozwala na łatwe rozdzielenie odpowiedzialności komponentów i klas oraz wstrzykiwanie zależności do poszczególnych klas.

\subsubsection{Architektura warstwowa}


Wzorzec programowania oparty na architekturze warstwowej (ang. tier architectrue) jest powszechny w procesie tworzenia aplikacji internetowych. Podejście te rozdziela logikę systemu od interfejsu użytkownika. W podejściu architektury trzywarstwowej wyróżniamy następujące warstwy:

\begin{figure}[h]
\centering
	\includegraphics[width=0.50\textwidth]{ntier.png}
	\caption[caption]{Warstwy w architekturze wielowarstwowej.}
	\label{fig:tier}
\end{figure}

\begin{itemize}
\item Warstwa prezentacji ang. presentation tie - odpowiedzialna za przedstawienie funkcjonalności użytkownikowi, umożliwiająca wyświetlanie oraz wprowadzanie danych. W tej warstwie ASP.NET używa się oprócz języka platformy (np. C\#) języków do opisów wyglądu strony (CSS, HTML, JavaScript). 
\item Warstwa biznesowa (ang. business tier) - w miejscu tym umieszczona jest logika aplikacji. Dane pozyskane z warstwy danych są przetwarzane by były w odpowiedni sposób przygotowane do wysyłania do warstwy prezentacji, jak również pozyskane od użytkownika przekształcane są w oczekiwanej formie, transportowane są do warstwy danych.

\item Warstwa danych (ang. persistance tier) - odpowiedzialna za komunikacji z zewnętrznymi serwisami zarządzającymi danymi, np. z bazą danych.
\end{itemize}

Dzięki zastosowaniu tego podejściu zyskujemy łatwość modyfikacji poszczególnych funkcjonalności, ponieważ zmiana w jednej warstwie nie wymusza zmian w całym systemie. Inną zaletą jest fakt, iż tworzone rozwiązania stają się bardziej przejrzyste. Za używaniem tego sposobu projektowania aplikacji przemawia to, że tę samą logikę możemy wykorzystać zarówno przy tworzeniu aplikacji internetowych jak i mobilnych. Wykorzystanie architektury warstwowej pozwala na reużywalność zaimplementowanych komponentów oraz ogranicza liczbę błędów (poprzez użycie wstrzykiwania zależności lub interfejsów), poza bieżącą warstwą nie ma dostępu do wewnętrznych metod. W stworzonym systemie oprócz przedstawionego podziału wprowadzono dodatkowy element przytrzymujący modele wykorzystywane między warstwami. Ich szczególnym przykładem są modele DAO, które używane są wyłącznie przez warstwę danych do komunikacji z bazą danych (mapowane są one przy użyciu Automappera). Dla realizacji założeń każda warstwa zaimplementowana została w osobnym projekcie.

\subsection{Projekt frontendu}
Do zdecydowania, czy ta sekcja powinna być zawarta w dokumentacji.
Co mogłoby się w niej znaleźć:
Ogólne overwiev, jakie ma być user expierience, jakaś idea stojąca za projektem frontendu?

\subsection{Projekt bazy danych}
To do:
Schemat tabel

\section{Podsumowanie i wnioski}


\newpage
\begin{thebibliography}{9}

\bibitem{oficjalna strona}
Oficjalna strona ASP.NET MVC
\\\texttt{https://www.asp.net/mvc}

\bibitem{oficjalna dokumentacja}
Oficjalna dokumentacja ASP.NET MVC
\\\texttt{https://docs.microsoft.com/pl\-pl/aspnet/\#pivot\=core\&panel\=core\_overview}

\bibitem{organizacja projektu}
Mosh Hamedani
\textit{Should you split your ASP.NET MVC project into multiple projects?}.
\\\texttt{https://programmingwithmosh.com/csharp/should-you-split-your\\-asp-net-mvc-project-into-multiple-projects/}

\bibitem{organizacja projektu}
Sandeep Singh Shekhawat
\textit{Onion Architecture In ASP.NET Core MVC}
\\\texttt{https://www.c-sharpcorner.com/article/onion-architecture-in-\\asp-net-core-mvc/}

\end{thebibliography}



\end{document}